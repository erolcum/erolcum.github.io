---
layout: post
title: PB -5- Arduino DHT11 sensÃ¶rÃ¼
---

Arduino'dan gelen sÄ±caklÄ±k ve nem bilgisini grafiksel (chart) olarak gÃ¶steriyoruz.<br><br>

![image](https://github.com/user-attachments/assets/3afcfb49-975b-40b8-b9d8-325bee438ffd)<br><br>

AÅŸaÄŸÄ±daki kodu Arduinoâ€™ya yÃ¼klÃ¼yoruz.. Ã–ncesinde, kÃ¼tÃ¼phane yÃ¶neticisi ile DHT-sensor-library ve Adafruit-Unified-Sensor kÃ¼tÃ¼phanelerini yÃ¼klÃ¼yoruz.<br><br>

```arduino
#include <DHT.h>
#define DHTPIN 2 //DHT pin 
#define DHTTYPE DHT11 
DHT dht(DHTPIN, DHTTYPE);

void setup() {
  Serial.begin(19200);
  dht.begin();
}

void loop() {
  float h = dht.readHumidity(); // Nem 
  float t = dht.readTemperature(); // SÄ±caklÄ±k 
  Serial.print("TP"); // header
  Serial.print(t);
  Serial.print("@"); // separator
  Serial.println(h); // println satÄ±r sonuna CRLF basar
  delay(250);
}
```
<br>
Bu kodu Arduino'ya yÃ¼kledikten sonra, her 250 milisaniyede bir sÄ±caklÄ±k ve nem bilgisi TP24.30@55 biÃ§iminde Purebasic'e iletilecektir. SensÃ¶r sÄ±caklÄ±ÄŸÄ± kÃ¼suratlÄ± veriyor ama nemi tamsayÄ± olarak veriyor. Forumda dolanÄ±rken resimde olduÄŸu gibi sinÃ¼s, cosinÃ¼s veya baÅŸka matematiksel grafikleri zamana baÄŸlÄ± olarak Ã§izebilen bir kod parÃ§asÄ± buldum. graph100 isimli forum kullanÄ±cÄ±sÄ± yazmÄ±ÅŸ, sanÄ±rÄ±m fransÄ±z kendisi. <br><br>

![image](https://github.com/user-attachments/assets/7120b727-d2b3-4821-9ea8-0b3499445430)<br><br>

Kodu biraz oynayarak, aÅŸaÄŸÄ±daki hale getirdim. Kodu **chart.pb** olarak boÅŸ bir dizine kaydedin. <br><br>

```purebasic
; https://www.purebasic.fr/english/viewtopic.php?t=60077&start=18
; chart module from user : graph100 in forum
DeclareModule Graph
  
  Structure Graph_pt_point_d
    x.d
    y.d
  EndStructure
  
  Structure Graph_pt
    *graph.Graph
    color.l
    line.b
    List pt.d()
  EndStructure
  
  Structure Graph
    pos.Graph_pt_point_d
    dimension.POINT
    nb_point.l
    List list_des_pt.Graph_pt()
    maxi.d
    mini.d
    ratio_w.d
    ratio_h.d
    Name.s
  EndStructure
  
  Declare.i Graph_Init(x, y, width, height, nb_point, Name.s = "")
  Declare.i Graph_AddSerie(*graph.Graph, color.l, Line.b = #False)
  Declare.i Graph_FreeSerie(*graph.Graph, *adresse_serie)
  Declare Graph_AddPoint(*adresse_serie.Graph_pt, value.d)
  Declare Graph_Draw(*graph.Graph)
EndDeclareModule

Module Graph
  
  Procedure.d Maxi_delta(value.d, delta.d)
    If delta = 0
      ProcedureReturn Round(value, #PB_Round_Up) + 0.5
    Else
      p10.d = Pow(10, Round(Log10(Abs(delta)), #PB_Round_Down))
      ProcedureReturn Round(value / p10, #PB_Round_Up) * p10
    EndIf
  EndProcedure
  
  Procedure.d Mini_delta(value.d, delta.d)
    If delta = 0
      ProcedureReturn Round(value, #PB_Round_Down) - 0.5
    Else
      p10.d = Pow(10, Round(Log10(Abs(delta)), #PB_Round_Down))
      ProcedureReturn Round(value / p10, #PB_Round_Down) * p10
    EndIf
  EndProcedure
  
  Procedure.i Graph_Init(x, y, width, height, nb_point, Name.s = "")
    *graph.Graph = AllocateMemory(SizeOf(Graph))
    InitializeStructure(*graph, Graph)
    *graph\pos\x = x
    *graph\pos\y = y
    *graph\dimension\x = width
    *graph\dimension\y = height
    *graph\nb_point = nb_point
    *graph\ratio_w = *graph\dimension\x / *graph\nb_point
    *graph\Name = Name
    ProcedureReturn *graph
  EndProcedure
  
  Procedure.i Graph_AddSerie(*graph.Graph, color.l, Line.b = #False) ; serinin adresini dÃ¶ndÃ¼rÃ¼r
    *new_serie = AddElement(*graph\list_des_pt())
    InitializeStructure(*new_serie, Graph_pt)
    *graph\list_des_pt()\color = color
    *graph\list_des_pt()\graph = *graph
    *graph\list_des_pt()\line = Line
    ProcedureReturn *new_serie
  EndProcedure
  
  Procedure.i Graph_FreeSerie(*graph.Graph, *adresse_serie) 
    ChangeCurrentElement(*graph\list_des_pt(), *adresse_serie)
    FreeList(*graph\list_des_pt()\pt())
    DeleteElement(*graph\list_des_pt())
  EndProcedure
  
  Procedure Graph_AddPoint(*adresse_serie.Graph_pt, value.d)
    LastElement(*adresse_serie\pt())
    AddElement(*adresse_serie\pt())
    *adresse_serie\pt() = value
    
    If ListSize(*adresse_serie\pt()) > *adresse_serie\graph\nb_point
      FirstElement(*adresse_serie\pt())
      DeleteElement(*adresse_serie\pt())
    EndIf
  EndProcedure
  
  Procedure Graph_Draw(*graph.Graph)
    Line(*graph\pos\x - 1, *graph\pos\y - 1, *graph\dimension\x + 2, 1, #Green)
    Line(*graph\pos\x - 1, *graph\pos\y - 1, 1, *graph\dimension\y + 2, #Green)
    Line(*graph\pos\x - 1, *graph\pos\y - 1 + *graph\dimension\y + 2, *graph\dimension\x + 2, 1, #Green)
    Line(*graph\pos\x - 1 + *graph\dimension\x + 2, *graph\pos\y - 1, 1, *graph\dimension\y + 2, #Green)
    
    j = 4
    For i = 69 To 621 Step 69
      Line(*graph\pos\x + i, *graph\pos\y  + *graph\dimension\y - 3, 1, 10, #Green)
      DrawText(*graph\pos\x + i - 6, *graph\pos\y  + *graph\dimension\y + 8, Str(j), #Green, 0)
      j + 4 
    Next
    DrawText(*graph\pos\x + 640, *graph\pos\y  + *graph\dimension\y + 8, "secs", #Green, 0)
    
    If *graph\Name
      Protected titre$ = " " + *graph\Name + " "
      Protected w = TextWidth(titre$), h = TextHeight(titre$)
      Protected x.d = *graph\pos\x + *graph\dimension\x / 2 - w / 2, y.d = *graph\pos\y - h / 2
      DrawText(x ,y , titre$, #Green)
      Line(x - 1, y - 1, w + 1, 1, #Green)
      Line(x - 1, y - 1, 1, h + 1, #Green)
      Line(x - 1, y - 1 + h + 1, w + 2, 1, #Green)
      Line(x - 1 + w + 1, y - 1, 1, h + 2, #Green)
    EndIf
    
    DrawText(*graph\pos\x + *graph\dimension\x + 2, *graph\pos\y - 1, StrD(*graph\maxi), #Green)
    DrawText(*graph\pos\x + *graph\dimension\x + 2, *graph\pos\y - 1 + *graph\dimension\y +
                                                    2 - TextHeight(" "), StrD(*graph\mini), #Green)
    *graph\ratio_h = *graph\dimension\y / (*graph\maxi - *graph\mini)
    mini.d = *graph\mini
    
    If Sign(*graph\maxi) <> Sign(*graph\mini)
      Line(*graph\pos\x, *graph\pos\y + *graph\dimension\y + mini * *graph\ratio_h, *graph\dimension\x, 1, #Green)
      DrawText(*graph\pos\x + *graph\dimension\x + 2, *graph\pos\y + *graph\dimension\y +
                                                      mini * *graph\ratio_h - TextHeight(" ") / 2, "0", #Green)
    EndIf
    
    *graph\maxi = -Infinity()
    *graph\mini = Infinity()
    
    ForEach *graph\list_des_pt()
      index = 0
      If *graph\list_des_pt()\line = #False
        ForEach *graph\list_des_pt()\pt()
          If *graph\list_des_pt()\pt() > *graph\maxi : *graph\maxi = *graph\list_des_pt()\pt() : EndIf
          If *graph\list_des_pt()\pt() < *graph\mini : *graph\mini = *graph\list_des_pt()\pt() : EndIf
          Line(*graph\pos\x + index * *graph\ratio_w, *graph\pos\y + 
                                                      *graph\dimension\y - (*graph\list_des_pt()\pt() - mini)**graph\ratio_h,
               1, 1, *graph\list_des_pt()\color)
          index + 1
        Next
        
      Else
        *adr.Double = FirstElement(*graph\list_des_pt()\pt())
        old_x.d = *graph\pos\x + index * *graph\ratio_w
        old_y.d = *graph\pos\y + *graph\dimension\y - (*graph\list_des_pt()\pt() - mini) * *graph\ratio_h
        ForEach *graph\list_des_pt()\pt()
          If *graph\list_des_pt()\pt() > *graph\maxi : *graph\maxi = *graph\list_des_pt()\pt() : EndIf
          If *graph\list_des_pt()\pt() < *graph\mini : *graph\mini = *graph\list_des_pt()\pt() : EndIf
          x.d = *graph\pos\x + index * *graph\ratio_w
          y.d = *graph\pos\y + *graph\dimension\y - (*graph\list_des_pt()\pt() - mini) * *graph\ratio_h
          LineXY(x, y, old_x, old_y, *graph\list_des_pt()\color)
          old_x = x
          old_y = y
          index + 1
        Next
      EndIf
      
      If LastElement(*graph\list_des_pt()\pt())
        DrawText(*graph\pos\x + *graph\dimension\x + 2,
                 *graph\pos\y + *graph\dimension\y-(*graph\list_des_pt()\pt() - mini) * *graph\ratio_h - TextHeight(" ") / 2, 
                 StrD(*graph\list_des_pt()\pt()), *graph\list_des_pt()\color)
      EndIf
    Next
    
    delta.d = *graph\maxi - *graph\mini
    *graph\maxi = Maxi_delta(*graph\maxi, delta)
    *graph\mini = Mini_delta(*graph\mini, delta)
    If delta = 0 : delta = 1 : EndIf
    
  EndProcedure
EndModule

```
<br>

GeÃ§en yazÄ±da olduÄŸu gibi burada da Mk-soft'un seri port'u thread ile okuyan kodunu kullandÄ±m. AÅŸaÄŸÄ±daki kodu da **comPort.pb** olarak aynÄ± dizine kaydedin.<br><br>

```purebasic
;-TOP
; https://www.purebasic.fr/english/viewtopic.php?t=79759
; Comment : Comport Manager Over Thread and Callback
; Author  : mk-soft
; Version : v0.07.1
; Created : 26.01.2018
; Updated : 03.09.2022

; *****************************************************************************

CompilerIf #PB_Compiler_Thread = 0
  CompilerError "Use Option Threadsafe!"
CompilerEndIf

Prototype ProtoReceiveCB(Text.s)
Prototype ProtoStatusCB(Status, *ComData)

Enumeration
  #ComThread_Stopped
  #ComThread_Startup
  #ComThread_Running
EndEnumeration

Enumeration
  #ComStatus_Nothing
  #ComStatus_OpenPort
  #ComStatus_ClosePort
  #ComStatus_ErrorOpenPort
  #ComStatus_ErrorSend
  #ComStatus_ErrorReceive
  #ComStatus_ErrorDataSize
EndEnumeration

Structure udtComData
  ; Header
  ThreadID.i
  Exit.i
  Status.i
  ; Port Data
  ComID.i
  Port.s
  Baud.i
  Parity.i
  DataBit.i
  StopBit.i
  Handshake.i
  BufferSize.i
  ; End Of Text
  EndOfText.s
  ; Send Data
  SendSignal.i
  SendCount.i
  SendText.s
  SendError.i
  ; Receive data
  ReceiveCount.i
  ReceiveText.s
  ReceiveError.i
  ; Callback
  *StatusCB.ProtoStatusCB
  *ReceiveCB.ProtoReceiveCB
EndStructure

Procedure thComport(*ComData.udtComData)
  
  Protected *Send, *Receive, SendText.s, SendLen, ReceiveText.s, ReceiveLen, Pos
  
  With *ComData
    ; Startup
    \Status = #ComThread_Startup
    \SendCount = 0
    \ReceiveCount = 0
    \ComID = OpenSerialPort(#PB_Any, \Port, \Baud, \Parity, \DataBit, \StopBit, \Handshake, \BufferSize, \BufferSize)
    If \ComID
      \Status = #ComThread_Running
    Else
      If \StatusCB
        \StatusCB(#ComStatus_ErrorOpenPort, *ComData)
      EndIf
      \Status = #ComThread_Stopped
      ProcedureReturn 0
    EndIf
    If \StatusCB
      \StatusCB(#ComStatus_OpenPort, *ComData)
    EndIf
    *Send = AllocateMemory(\BufferSize)
    *Receive = AllocateMemory(\BufferSize)
    ; Loop
    Repeat
      If \SendSignal
        SendText = \SendText + \EndOfText
        SendLen = StringByteLength(SendText, #PB_Ascii)
        If SendLen <= \BufferSize
          PokeS(*Send, SendText, SendLen, #PB_Ascii)
          If WriteSerialPortData(\ComID, *Send, SendLen) = 0
            \SendError = SerialPortError(\ComID)
            If \StatusCB
              \StatusCB(#ComStatus_ErrorSend, *ComData)
            EndIf
          Else
            \SendError = 0
            \SendCount + 1
          EndIf
        Else
          If \StatusCB
            \StatusCB(#ComStatus_ErrorDataSize, *ComData)
          EndIf
        EndIf
        \SendSignal = #False
      EndIf
      ReceiveLen = AvailableSerialPortInput(\ComID)
      If ReceiveLen
        ReceiveLen = ReadSerialPortData(\ComID, *Receive, ReceiveLen)
        If ReceiveLen = 0
          \ReceiveError = SerialPortError(\ComID)
          If \StatusCB
            \StatusCB(#ComStatus_ErrorReceive, *ComData)
          EndIf
        Else
          \ReceiveError = 0
        EndIf
        ReceiveText + PeekS(*Receive, ReceiveLen, #PB_Ascii)
        Repeat
          pos = FindString(ReceiveText, \EndOfText, 1, #PB_String_NoCase)
          If pos
            \ReceiveText = Left(ReceiveText, pos - 1)
            ReceiveText = Mid(ReceiveText, pos + Len(\EndOfText))
            \ReceiveCount + 1
            If \ReceiveCB
              \ReceiveCB(\ReceiveText)
            EndIf
          EndIf
        Until pos = 0
      EndIf
      Delay(10)
    Until \Exit
    ; Shutdown
    If IsSerialPort(\ComID) : CloseSerialPort(\ComID) : EndIf 
    If \StatusCB
      \StatusCB(#ComStatus_ClosePort, *ComData)
    EndIf
    FreeMemory(*Send)
    FreeMemory(*Receive)
    \Status = #ComThread_Stopped
    \ComID = 0
    \Exit = 0
    ProcedureReturn 1
  EndWith
  
EndProcedure

; ----

Procedure.s SerialPortErrorText(ErrorCode)
  Protected r1.s
  
  Select ErrorCode
    Case #PB_SerialPort_RxOver      : r1 = "An input buffer overflow has occurred."
    Case #PB_SerialPort_OverRun     : r1 = "A character-buffer overrun has occurred."
    Case #PB_SerialPort_RxParity    : r1 = "The hardware detected a parity error."
    Case #PB_SerialPort_Frame       : r1 = "The hardware detected a framing error."
    Case #PB_SerialPort_Break       : r1 = "The hardware detected a break condition."
    Case #PB_SerialPort_TxFull      : r1 = "The application tried to transmit a character but the output buffer was full."
    Case #PB_SerialPort_IOE         : r1 = "An I/O error occurred during communications with the device."
    Case #PB_SerialPort_WaitingCTS  : r1 = "Specifies whether transmission is waiting for the CTS (clear-To-send) signal to be sent."
    Case #PB_SerialPort_WaitingDSR  : r1 = "Specifies whether transmission is waiting for the DSR (Data-set-ready) signal to be sent."
    Case #PB_SerialPort_WaitingRLSD : r1 = "Specifies whether transmission is waiting for the RLSD (receive-line-signal-detect) signal to be sent."
    Case #PB_SerialPort_XoffReceived: r1 = "Specifies whether transmission is waiting because the XOFF character was received."
    Case #PB_SerialPort_XoffSent    : r1 = "Specifies whether transmission is waiting because the XOFF character was transmitted."
    Case #PB_SerialPort_EOFSent     : r1 = "Specifies whether the end-of-file (EOF) character has been received."
    Default                         : r1 = "ErrorCode " + Hex(ErrorCode)
  EndSelect
  ProcedureReturn r1
EndProcedure

; ----

; Threaded String Helper

Procedure AllocateString(String.s)
  Protected *mem
  *mem = AllocateMemory(StringByteLength(String) + SizeOf(Character))
  If *mem
    PokeS(*mem, String)
  EndIf
  ProcedureReturn *mem
EndProcedure

Procedure.s FreeString(*Mem)
  Protected result.s
  If *Mem
    result = PeekS(*Mem)
    FreeMemory(*Mem)
  EndIf
  ProcedureReturn result
EndProcedure

```
<br>

Ãœstteki dosyalarÄ± kullanan aÅŸaÄŸÄ±daki kodu da **dht11.pb** olarak aynÄ± dizine kaydedin.<br><br>

```purebasic
XIncludeFile "chart.pb"
XIncludeFile "comPort.pb"

  
Global ComData.udtComData, temperature$, humidity$
Define.f maxTemperature, maxHumidity
  
  Enumeration EventCustomValue #PB_Event_FirstCustomValue
    #My_Event_NewData
    #My_Event_NewState
  EndEnumeration
  
  ; ---------------------------------------------------------------------------  

    Procedure ReceiveCB(Text.s)
    PostEvent(#My_Event_NewData, 0, 0, 0, AllocateString(Text))
  EndProcedure
  
  Procedure MyEventNewDataCB()
    Protected Text.s
    Text = FreeString(EventData())
    If Left(Text, 2) = "TP"
      temperature$ = StringField(Text, 1, "@")
      temperature$ = Right(temperature$, (Len(temperature$) - 2))
      humidity$ = Right(Text, Len(text) - (Len(temperature$) + 3))
    EndIf 
  EndProcedure

  BindEvent(#My_Event_NewData, @MyEventNewDataCB())
  
  ; ---------------------------------------------------------------------------
  
  Procedure StatusCB(Status, *ComData.udtComData)
    PostEvent(#My_Event_NewState, 0, 0, Status, *ComData)
  EndProcedure
  
  Procedure MyEventNewStateCB()
    Protected Text.s, Status, *ComData.udtComData
    Status = EventType()
    *ComData = EventData()
    Select Status
      Case #ComStatus_OpenPort
        Text = "ComStatus: Open Port " + *ComData\Port
      Case #ComStatus_ClosePort
        Text = "ComStatus: Close Port " + *ComData\Port
      Case #ComStatus_ErrorOpenPort
        Text = "ComError: Open Port " + *ComData\Port
      Case #ComStatus_ErrorSend
        Text = "ComError Send: Port " + *ComData\Port + " - " + SerialPortErrorText(*ComData\SendError)
      Case #ComStatus_ErrorReceive
        Text = "ComError Receive: Port " + *ComData\Port + " - " + SerialPortErrorText(*ComData\ReceiveError)
      Case #ComStatus_ErrorDataSize
        Text = "ComError Send: Port " + *ComData\Port + " - Send data size to big."
    EndSelect
    If Bool(Text)
      StatusBarText(0, 0, Text)
    EndIf
  EndProcedure
  
  BindEvent(#My_Event_NewState, @MyEventNewStateCB())
  
  ; ---------------------------------------------------------------------------
  
  Procedure InitComport()
    With ComData
      If \Status
        ProcedureReturn 2 ; Always running
      EndIf
      \Port = "COM3"
      \Baud = 19200
      \Parity = #PB_SerialPort_NoParity
      \DataBit = 8
      \StopBit = 1
      \Handshake = #PB_SerialPort_NoHandshake
      \BufferSize = 2048
      \EndOfText = #CRLF$
      \StatusCB = @StatusCB()
      \ReceiveCB = @ReceiveCB()
      \ThreadID = CreateThread(@thComport(), ComData)
      If Not \ThreadID
        ProcedureReturn 0 ; Error create thread
      Else
        ProcedureReturn 1 ; ok
      EndIf
    EndWith
  EndProcedure
  
  ; ---------------------------------------------------------------------------

OpenWindow(0, 0, 0, 770, 620, "Arduino Hava istasyonu", #PB_Window_ScreenCentered | #PB_Window_SystemMenu)
CanvasGadget(0, 10, 10, 750, 580)
CreateStatusBar(0, WindowID(0))
AddStatusBarField(#PB_Ignore)

AddWindowTimer(0, 1, 2000)

InitComport()

UseModule Graph

;{ init graphics
; 1000 olan nokta sayÄ±sÄ± deÄŸiÅŸirse x ekseni daralÄ±r ya da geniÅŸler
*graph.Graph = Graph_Init(10, 20, 700, 200, 1000, "Temperature")
*ad_temperature = Graph_AddSerie(*graph, #Red, #True)
;*ad_cosinus = Graph_AddSerie(*graph, RGB(200, 200, 255), #True) ; 2saniye testi

*graph_humidity.Graph = Graph_Init(10, 290, 700, 200, 1000, "Humidity")
*ad_humidity = Graph_AddSerie(*graph_humidity, #Blue, #True)
;}

_dt_lim = 40 ; bunu deÄŸiÅŸtirince x ekseni daralÄ±r ya da geniÅŸler
time = ElapsedMilliseconds()

a=-3

  ; ---------------------------------------------------------------------------
Repeat
  
  ;{ event
  Repeat
    event = WindowEvent()
    Select event
        
      Case #PB_Event_Timer		
        If EventTimer() = 1
          If a=-3 : a=3 : ElseIf a=3 : a=-3 : EndIf
        EndIf
    EndSelect
    
    If event = #PB_Event_CloseWindow
      If ComData\Status
        ComData\Exit = 1
      EndIf 
      End
    EndIf
    
  Until event = 0
  ;}
  
  ;{ fps ayarÄ±
  dt = ElapsedMilliseconds() - time
  If dt < _dt_lim
    Delay(_dt_lim - dt) 
  EndIf
  dt = ElapsedMilliseconds() - time
  time = ElapsedMilliseconds() 
  ;}
  Graph_AddPoint(*ad_temperature, ValF(temperature$) ) ;Cos(2* 3.14 * time)) 
  ;Graph_AddPoint(*ad_cosinus, a) ; 2saniye testi 
  Graph_AddPoint(*ad_humidity, ValF(humidity$))
  ;{ chart Ã§izimi
  StartDrawing(CanvasOutput(0))
  Box(0, 0, OutputWidth(), OutputHeight(), 0)
  Graph_Draw(*graph)
  Graph_Draw(*graph_humidity)
  If maxTemperature < ValF(temperature$) : maxTemperature = ValF(temperature$) : EndIf
  If maxHumidity < ValF(humidity$) : maxHumidity = ValF(humidity$) : EndIf
  DrawText(150, 540, "Max. Temperature : " + StrF(maxTemperature,2) , #Green, 0)
  DrawText(450, 540, "Max. Humidity : " + StrF(maxHumidity,2) , #Green, 0)
  StopDrawing()
  ;}
  
ForEver

```

<br><br>
![image](https://github.com/user-attachments/assets/0e461cb4-8a4e-4dbf-84a0-a4e5acd40def)
<br><br>
Bu grafiÄŸi almak iÃ§in haliyle sensÃ¶re hohlamam gerekti biraz  ğŸ˜„ <br><br>
Siteyi, About sekmesinden baÅŸlayarak okuyun. YazÄ±larÄ± da sÄ±rayla okuyun. Aksi halde Ã¶nceki yazÄ±larda belirttiÄŸim pÃ¼f noktalarÄ± kaÃ§Ä±rmÄ±ÅŸ olursun.<br><br>
VB veya C# .Net ile karÅŸÄ±laÅŸtÄ±rmak gerekirse PB'de kodlar biraz uzuyor. Ama daha anlaÅŸÄ±lÄ±r olarak gÃ¶rÃ¼yorum ben. .Net'de herÅŸeyin kÃ¼tÃ¼phanesini bulmak mÃ¼mkÃ¼n, bazÄ± basit iÅŸlemler bile PB'de kodlama yapÄ±larak Ã§Ã¶zÃ¼lÃ¼yor. BÃ¶ylece konuyu daha temelden anlamÄ±ÅŸ oluyorsun. Forumda hertÃ¼rlÃ¼ kodu bulabiliyorsun. BulamasanÄ±z bile foruma sorabiliyorsun. 
<br><br>
PB'in gÃ¼zelliÄŸi de ÅŸu ki, programÄ±n, .Net veya Java'da olduÄŸu gibi baÅŸka bir kÃ¼tÃ¼phaneye baÄŸÄ±mlÄ± olarak deÄŸil tamamen kendi kendine Ã§alÄ±ÅŸÄ±yor olmasÄ±dÄ±r. YukarÄ±daki kodlarÄ± alÄ±n, PB editÃ¶rÃ¼ne yapÄ±ÅŸtÄ±rÄ±n. Program Ã§alÄ±ÅŸacaktÄ±r. <br><br>
PB'in bir baÅŸka gÃ¼zelliÄŸi de thread konusunun sade ve anlaÅŸÄ±lÄ±r olmasÄ±dÄ±r. Ã–rneÄŸin bu iÅŸi .Net ile yapsaydÄ±k, seri porttan gelen bilginin grafiÄŸe veya forma aktarÄ±lmasÄ± iÃ§in Delegate, Invoke gibi komutlar kullanmak gerekecekti. .Net iÃ§in thread konusunu araÅŸtÄ±rÄ±rsan, Ã§ok karmaÅŸÄ±k ve zor olduÄŸunu gÃ¶rÃ¼rsÃ¼n. Sadece thread konusunu anlatan .Net kitaplarÄ±nÄ±n yazÄ±ldÄ±ÄŸÄ±na ÅŸahit olabilirsin. PB'de ise thread, Ã§ok Ã§ok daha kolay ve anlaÅŸÄ±lÄ±r..



